"ModGuts" preliminary conclusions
=================================

The GHC API exports a function

  coreModule :: DesugaredMod m => m -> ModGuts

There is only one instance of that DesugaredMod class: DesugaredModule, which
instantiates coreModule to be simply dm_core_module:

  data DesugaredModule =
    DesugaredModule { dm_typechecked_module :: TypecheckedModule
                    , dm_core_module        :: ModGuts
                    }

These DesugaredModules are created in

  desugarModule :: GhcMonad m => TypecheckedModule -> m DesugaredModule

in GHC.hs. However, desugarModule is never called from "load" -- dead end.

So let's focus on ModGuts itself.  There are 3 places in the compiler where
ModGuts are created "from scratch" (using the ModGuts constructor directly):

1. tcRnExtCore :: HscEnv -> HsExtCore RdrName -> IO (Messages, Maybe ModGuts)
   in typecheck/TcRnDriver.lhs

2. deSugar :: HscEnv -> ModLocation -> TcGblEnv -> IO (Messages, Maybe ModGuts)
   in deSugar/Desugar.lhs

3. mkModGuts :: Module -> SafeHaskellMode -> CoreProgram -> IO ModGuts
   in main/HscMain.hs

Neither (1) nor (3) is called from "load", but (2) is through the following call stack:

  [Desugar.lhs] deSugar :: HscEnv -> ModLocation -> TcGblEnv -> IO (Messages, Maybe ModGuts)
  [HscMain.hs] hscDesugar' :: ModLocation -> TcGblEnv -> Hsc ModGuts
  [HscMain.hs] genericHscBackend :: HsCompiler a -> TcGblEnv -> ModSummary -> Maybe Fingerprint -> Hsc a
  [HscMain.hs] hscInteractiveCompiler :: HsCompiler InteractiveResult
  [HscMain.hs] hscCompileInteractive :: Compiler (InteractiveStatus, ModIface, ModDetails)
  [DriverPipeline.hs] compile :: HscEnv -> ModSummary -> Int -> Int -> Maybe ModIface -> Maybe Linkable -> SourceModified -> IO HomeModInfo
  [GhcMake.hs] upsweep_mod :: HscEnv -> HomePackageTable -> ([ModuleName],[ModuleName]) -> ModSummary -> Int -> Int -> IO HomeModInfo
  [GhcMake.hs] upsweep :: GhcMonad m => HomePackageTable -> ([ModuleName],[ModuleName]) -> (HscEnv -> IO ()) -> [SCC ModSummary] -> m (SuccessFlag, [ModSummary])
  [GhcMake.hs] load :: GhcMonad m => LoadHowMuch -> m SuccessFlag

That HsCompiler data type (defined in HscMain.hs) seems interesting:

  data HsCompiler a = HsCompiler {
      hscNoRecomp :: ModIface -> Hsc a,
      hscRecompile :: ModSummary -> Maybe Fingerprint -> Hsc a,
      hscBackend :: TcGblEnv -> ModSummary -> Maybe Fingerprint -> Hsc a,
      hscGenBootOutput :: TcGblEnv -> ModSummary -> Maybe Fingerprint -> Hsc a,
      hscGenOutput :: ModGuts -> ModSummary -> Maybe Fingerprint -> Hsc a
    }

Perhaps an appropriate point to plug our own stuff in? -- But maybe not, as
this only happens from 'compile' down, which is dealing with a single module.
In fact, this comment (above HscEnv) is reelvant:

  -- Historical note: \"hsc\" used to be the name of the compiler binary,
  -- when there was a separate driver and compiler.  To compile a single
  -- module, the driver would invoke hsc on the source code... so nowadays
  -- we think of hsc as the layer of the compiler that deals with compiling
  -- a single module.

--------------------------------------------------------------------------------

We have access to ModGuts through the plugin architecture, but there are a few
downsides:

1. This means that the code for the plugin needs to reside in a separate
package, because we can only load plugins through a ModuleName (although we
could patch ghc to fix that)

2. It is hard to share state with the plugin (fixing the above would fix that, too)

3. Most importantly, it means we need to work at the level of Core, which may
or may not be desirable.

Expanding on (3):

- http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/HscMain
  describes that type checking is done *before* the desugarer (which is
  responsible for turning the original AST into core), and that this means that
  "error messages can display precisely the syntax that the user wrote" and
  moreover "desugaring is not required to preserve type-inference properties."

- http://darcs.haskell.org/ghc/docs/comm/the-beast/types.html talks about the
  different type systems for the AST and Core, and "hybrid" types

Hooking into the typechecker
============================

The type checker gets called through the callstack

    [TcRnDriver.hs] tcRnModule :: HscEnv -> HscSource-> Bool -> HsParsedModule -> IO (Messages, Maybe TcGblEnv)
    [HscMain.hs] tcRnModule' :: HscEnv -> ModSummary -> Bool -> HsParsedModule -> Hsc TcGblEnv
    [HscMain.hs] hscFileFrontEnd :: ModSummary -> Hsc TcGblEnv
    [HscMain.hs] genericHscRecompile :: HsCompiler a -> ModSummary -> Maybe Fingerprint -> Hsc a
(*) [HscMain.hs] hscInteractiveCompiler :: HsCompiler InteractiveResult
    [HscMain.hs] hscCompileInteractive :: Compiler (InteractiveStatus, ModIface, ModDetails)
    [DriverPipeline.hs] compile :: HscEnv -> ModSummary -> Int -> Int -> Maybe ModIface -> Maybe Linkable -> SourceModified -> IO HomeModInfo
    [GhcMake.hs] upsweep_mod :: HscEnv -> HomePackageTable -> ([ModuleName],[ModuleName]) -> ModSummary -> Int -> Int -> IO HomeModInfo
    [GhcMake.hs] upsweep :: GhcMonad m => HomePackageTable -> ([ModuleName],[ModuleName]) -> (HscEnv -> IO ()) -> [SCC ModSummary] -> m (SuccessFlag, [ModSummary])
    [GhcMake.hs] load :: GhcMonad m => LoadHowMuch -> m SuccessFlag

This callstack is shared with the one for the desugarer (above) from the marked
line (*).

Non-unique Unique
=================

From http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType:

    One of the important things when working with Core is that variable
    shadowing is allowed. In other words, it is possible to come across
    a definition of a variable that has the same name (realUnique)
    as some other one that is already in scope.

(TODO: verify that it's still the case in the newer GHC.)

In other words, even at the Core level (and ever more so before the desugaring), we can't use the Unique numbers as global unique identifiers for our variables. We can't have a map from SrcSpan to Unique and from Unique to Id (containing a SrcSpan and a type). Instead we need a map from SrcSpan to Id directly and that takes much more memory. To fix this, we can hash the Ids and so assign our own unique names. Or traverse our db (or the Core code) and reassign the Unique identifiers using some GHC helper functions designed for that.
