From 2684a8f9aeaec8189e4ebbc01fe657469253d9e8 Mon Sep 17 00:00:00 2001
From: Edsko de Vries <edsko@well-typed.com>
Date: Fri, 3 May 2013 09:46:20 +0100
Subject: [PATCH] Provide access to the TID of the runStmt sandbox

We were emulating this inside ide-backend itself, but that meant that we might
send a UserInterrupt to ghc while compiling the statement rather than to the
user code, with all kinds of horrid results (exception ending up as part of
some thunk due to some unsafePerformIO, thrown every time we touched that
thunk?). Hard to reproduce and even harder to figure out what's going on
precisely. My moving this to inside ghc we hopefully avoid this problem.
---
 compiler/main/InteractiveEval.hs | 17 ++++++++++-------
 ghc/GhciMonad.hs                 |  4 +++-
 2 files changed, 13 insertions(+), 8 deletions(-)

diff --git a/compiler/main/InteractiveEval.hs b/compiler/main/InteractiveEval.hs
index b4cf6b8..0a82d5b 100644
--- a/compiler/main/InteractiveEval.hs
+++ b/compiler/main/InteractiveEval.hs
@@ -186,14 +186,14 @@ findEnclosingDecls hsc_env inf =
 
 -- | Run a statement in the current interactive context.  Statement
 -- may bind multple values.
-runStmt :: GhcMonad m => String -> SingleStep -> m RunResult
+runStmt :: GhcMonad m => String -> SingleStep -> MVar (Maybe ThreadId) -> m RunResult
 runStmt = runStmtWithLocation "<interactive>" 1
 
 -- | Run a statement in the current interactive context.  Passing debug information
 --   Statement may bind multple values.
 runStmtWithLocation :: GhcMonad m => String -> Int -> 
-                       String -> SingleStep -> m RunResult 
-runStmtWithLocation source linenumber expr step =
+                       String -> SingleStep -> MVar (Maybe ThreadId) -> m RunResult 
+runStmtWithLocation source linenumber expr step tidMVar =
   do
     hsc_env <- getSession
 
@@ -215,7 +215,7 @@ runStmtWithLocation source linenumber expr step =
           withVirtualCWD $
             withBreakAction (isStep step) dflags' breakMVar statusMVar $ do
                 let thing_to_run = unsafeCoerce# hval :: IO [HValue]
-                liftIO $ sandboxIO dflags' statusMVar thing_to_run
+                liftIO $ sandboxIO dflags' statusMVar tidMVar thing_to_run
               
         let ic = hsc_IC hsc_env
             bindings = (ic_tythings ic, ic_rn_gbl_env ic)
@@ -381,10 +381,13 @@ foreign import ccall "&rts_breakpoint_io_action"
 -- thread blocked (forkIO inherits mask from the parent, #1048), and unblock
 -- only while we execute the user's code.  We can't afford to lose the final
 -- putMVar, otherwise deadlock ensues. (#1583, #1922, #1946)
-sandboxIO :: DynFlags -> MVar Status -> IO [HValue] -> IO Status
-sandboxIO dflags statusMVar thing =
+sandboxIO :: DynFlags -> MVar Status -> MVar (Maybe ThreadId) -> IO [HValue] -> IO Status
+sandboxIO dflags statusMVar tidMVar thing =
    mask $ \restore -> -- fork starts blocked
-     let runIt = liftM Complete $ try (restore $ rethrow dflags thing)
+     let thing' = gbracket (myThreadId >>= putMVar tidMVar . Just)
+                           (\() -> modifyMVar_ tidMVar (\_ -> return Nothing))
+                           (\() -> thing)
+         runIt  = liftM Complete $ try (restore $ rethrow dflags thing')
      in if dopt Opt_GhciSandbox dflags
         then do tid <- forkIO $ do res <- runIt
                                    putMVar statusMVar res -- empty: can't block
diff --git a/ghc/GhciMonad.hs b/ghc/GhciMonad.hs
index 55d8946..a9a46fc 100644
--- a/ghc/GhciMonad.hs
+++ b/ghc/GhciMonad.hs
@@ -45,6 +45,7 @@ import System.Environment
 import System.IO
 import Control.Monad as Monad
 import GHC.Exts
+import Control.Concurrent
 
 import System.Console.Haskeline (CompletionFunc, InputT)
 import qualified System.Console.Haskeline as Haskeline
@@ -261,9 +262,10 @@ runStmt expr step = do
     withProgName (progname st) $
     withArgs (args st) $
       reflectGHCi x $ do
+        _tidMVar <- liftIO $ newEmptyMVar
         GHC.handleSourceError (\e -> do GHC.printException e; 
                                         return Nothing) $ do
-          r <- GHC.runStmtWithLocation (progname st) (line_number st) expr step
+          r <- GHC.runStmtWithLocation (progname st) (line_number st) expr step _tidMVar
           return (Just r)
 
 runDecls :: String -> GHCi [GHC.Name]
-- 
1.7.12.4 (Apple Git-37)

