module Main (main) where

import System.Unix.Directory (withTemporaryDirectory)
import System.FilePath ((</>))

-- getExecutablePath is in base only for >= 4.6
import Data.IORef
import Control.Concurrent

import GHC hiding (flags, ModuleName, RunResult)
import qualified Config as GHC
import GhcMonad (liftIO)
import ErrUtils   ( Message )
import Outputable ( PprStyle, qualName, qualModule )
import qualified Outputable as GHC

import System.Process (readProcess)
import System.Directory (getDirectoryContents, copyFile)
import System.FilePath (takeExtension)
import Data.List ((\\))


--------------------------------------------------------------------------------

getGhcLibdir :: IO FilePath
getGhcLibdir = do
  let ghcbinary = "ghc-" ++ GHC.cProjectVersion
  out <- readProcess ghcbinary ["--print-libdir"] ""
  case lines out of
    [libdir] -> return libdir
    _        -> fail "cannot parse output of ghc --print-libdir"

runFromGhc :: Ghc a -> IO a
runFromGhc a = do
  libdir <- getGhcLibdir
  runGhc (Just libdir) a

compileInGhc :: FilePath            -- ^ target directory
             -> [Located String]    -- ^ dynamic flags for this run of runGhc
             -> (String -> IO ())   -- ^ handler for each SevOutput message
             -> Ghc ()
compileInGhc configSourcesDir dynOpts handlerOutput = do
    -- Determine files to process.
    cnts <- liftIO $ getDirectoryContents configSourcesDir
    let targets = map (configSourcesDir </>) $ filter ((== ".hs") . takeExtension) cnts
    handleSourceError (\_ -> error "uh oh") $ do
      -- Compute new GHC flags.
      flags0 <- getSessionDynFlags
      (flags1, _, _) <- parseDynamicFlags flags0 dynOpts
      let flags = flags1 {
                           hscTarget  = HscNothing,
                           ghcLink    = NoLink,
                           ghcMode    = CompManager,
                           verbosity  = 1,
                           log_action = collectSrcError handlerOutput
                         }
      defaultCleanupHandler flags $ do
        -- Set up the GHC flags.
        setSessionDynFlags flags
        -- Set up targets.
        oldTargets <- getTargets
        let targetIdFromFile file = TargetFile file Nothing
            addSingle filename = do
              addTarget Target
                { targetId           = targetIdFromFile filename
                , targetAllowObjCode = True
                , targetContents     = Nothing
                }
            fileFromTarget Target{targetId} =
              case targetId of
                TargetFile file Nothing -> file
                _ -> error "fileFromTarget: not a known target"
            oldFiles = map fileFromTarget oldTargets
        mapM_ addSingle (targets \\ oldFiles)
        mapM_ removeTarget $ map targetIdFromFile $ oldFiles \\ targets
        -- Load modules to typecheck and perhaps generate code, too.
        _loadRes <- load LoadAllTargets
        return ()

collectSrcError :: (String -> IO ())
                -> Severity -> SrcSpan -> PprStyle -> MsgDoc -> IO ()
collectSrcError handlerOutput SevOutput _srcspan style msg
  = let msgstr = GHC.showSDocForUser (qualName style,qualModule style) msg
     in handlerOutput msgstr
collectSrcError _ _ _ _ _
  = return ()

-----------------------
-- GHC version compat
--

type MsgDoc = Message

--------------------------------------------------------------------------------


-- * Server-side operations

-- TODO: Do we want to return partial error information while it's
-- generated by runGHC, e.g., warnings? We could either try to run checkModule
-- file by file (do depanalSource and then DFS over the resulting graph,
-- doing \ m -> load (LoadUpTo m)) or rewrite collectSrcError to place
-- warnings in an mvar instead of IORef and read from it into Progress,
-- as soon as they appear.
-- | This function runs in end endless loop, most of which takes place
-- inside the @Ghc@ monad, making incremental compilation possible.
ghcServerEngine :: FilePath -> Chan () -> Chan () -> IO ()
ghcServerEngine configSourcesDir req resp = do
  -- Submit static opts and get back leftover dynamic opts.
  (dOpts, _) <- parseStaticFlags []
  -- Init error collection and define the exception handler.
  runFromGhc $ dispatcher dOpts

 where
  dispatcher dOpts = do
    liftIO $ readChan req
    response <- ghcServerHandler configSourcesDir dOpts
    liftIO $ writeChan resp response
    dispatcher dOpts

ghcServerHandler :: FilePath -> [Located String] -> Ghc ()
ghcServerHandler configSourcesDir dOpts = do
  -- Setup progress counter. It goes from [1/n] onwards.
  counterIORef <- liftIO $ newIORef (1 :: Int)
  let -- Let GHC API print "compiling M ... done." for each module.
      -- TODO: verify that _ is the "compiling M" message
      handlerOutput msg = do
        oldCounter <- readIORef counterIORef
        putStrLn $ "~~~~~~ " ++ show oldCounter ++ ": " ++ msg
        modifyIORef counterIORef (+1)
  compileInGhc configSourcesDir dOpts handlerOutput

--------------------------------------------------------------------------------

check :: FilePath -> IO ()
check configSourcesDir = do
    -- Init session.
    req <- newChan
    resp <- newChan
    forkIO $ ghcServerEngine configSourcesDir req resp

    -- Test the computations.
    putStrLn "----- 1 ------"
    copyFile "test/AerrorB/B.hs" (configSourcesDir </> "B.hs")
    copyFile "test/AerrorB/A.hs" (configSourcesDir </> "A.hs")
    writeChan req ()
    _ <- readChan resp

    putStrLn "----- 2 ------"
    writeChan req ()
    _ <- readChan resp

    putStrLn "----- 3 ------"

main :: IO ()
main = withTemporaryDirectory "ide-backend-test" check

